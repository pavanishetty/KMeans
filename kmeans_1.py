# -*- coding: utf-8 -*-
"""KMeans-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e40YTD-SywNsS54Xpfogm8XQZjBa_-Zp
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import clear_output

#read dataset
#I used a specific path because I worked on google collab. Please change the path to execute
diabeticData = pd.read_csv("/content/diabetic_data.csv")

#Picks random sample of 1000 rows
diabeticDataSel = diabeticData.sample(1000).copy()

#downloaded the selected dataset for reference
#this dataset contains selected indices values
diabeticDataSel.to_csv(r'\diabeticData1000.csv')

diabeticDataSel

print(diabeticDataSel.columns.values)

#checks if there are any null values
diabeticDataSel.isna().sum()

'''1.a. Run K-means on the any 1000 data points with the following two
variables:‘time_in_hospital’, and ‘num_medications’ with the number of clusters
K = 2. Plot your clusters using a 2D scatter plot and report (print) the
centroid locations. Based on this plot, what are your thoughts on the
generated clusters? 
1.b. Test with different numbers of clusters K, running from K = 2 to K = 10
using the same variables in 1a. According to the scatter plots, which number of clusters do you think is the most appropriate? Justify your
response.
'''

features = ['time_in_hospital', 'num_medications']

#copy 'time_in_hospital', 'num_medications' data into variable 'data
data = diabeticDataSel[features]

''' plotClusters function gives scatter plot for datapoints by considering
 clusters and their respective centroids '''
 
def plotClusters(data, clusters, centroids, k):
    clear_output(wait=True)
    
    plt.title(f'KMeans Clustering k={k}')
    plt.xlabel('time_in_hospital')
    plt.ylabel('num_medications')
    plt.scatter(x=data.iloc[:,0], y=data.iloc[:,1], c=clusters)
    plt.scatter(x=centroids.T.iloc[:,0], y=centroids.T.iloc[:,1], c ="red", marker ="x")
    plt.savefig(f'KMeans Clustering with k={k}')
    plt.show()

#calcDist function is used to calculate euclidean distance between centroids, datapoints
def calcDist(x, y):
  dist = 0
  for j in range(0, len(x)):
   # print('j', x[j],y[j])
    dist = dist + (x[j] - y[j])**2
   # print('dist', dist)
  return dist**0.5

#dunnIndexVal function is used to calculate dunnIndex value
def dunnIndexVal(dataPoints, centroids):
  n = float('inf')

  for i in centroids:
    for j in centroids:
      
      if(i==j).all():continue
      dist = calcDist(i,j)
      n = min(n,dist)

  d = 0
  for p in centroids:
    for q in dataPoints:
      for r in dataPoints:
        if(q==r).all():continue
        dist = calcDist(q,r)
        d = max(d,dist)

  return n/d

'''this code snippet calculates KMeans for the given dataset by forming clusters
and their respective centroids and gives scatterplots from k=2 to k=10'''

dunnIndices = []
numOfClusters = []

#gives result be considering k=2,3,4,5,6,7,8,9,10
for k in range(2,11):
  maxIterations = 100
  numOfCentroids = k

#caculate centroids
  centroids = []
  for i in range(0,numOfCentroids):
    calCentroid = data.apply(lambda k: float(k.sample()))
    centroids.append(calCentroid)
  centroids = pd.concat(centroids, axis=1)

  '''getClusters function is used to calculate clusters based on euclidean 
     distance and returns minimum indices of the distances calculated'''
  def getClusters(data, centroids):
    dist = centroids.apply(lambda x: np.sqrt(((data - x) ** 2).sum(axis=1)))
  #print(dist)
    return dist.idxmin(axis=1)

  #calNewCentroids function is used to reassign centroids 
  def calNewCentroids(data, clusters, k):
    # new centroids are calculated by using gemometric mean
    centroids = data.groupby(clusters).apply(lambda x: np.exp(np.log(x).mean())).T 
    return centroids

  prevCentroids = pd.DataFrame()
  iter = 1
#print(prevCentroids)

  while iter < maxIterations and not centroids.equals(prevCentroids):
      prevCentroids = centroids
      clusters = getClusters(data, centroids)
      print('clusters', clusters)
      centroids = calNewCentroids(data, clusters, numOfCentroids)
      print(centroids)
      iter += 1
  plotClusters(data, clusters, centroids, k)

  '''c. Implement Dunn index (DI) cluster validity measure from scratch.
  Repeat the experiments in problem 1b and compute the corresponding
  DI indices'''
  
  #convert dataframes into array for plotting
  x = data.to_numpy()
  y = centroids.to_numpy()
  val = dunnIndexVal(x,y)

  #dunnIndices variable stores all dunn index values from k=2 to k=10
  dunnIndices.append(val)
  #numOfClusters stores all clusters as an array
  numOfClusters.append(k)

#plot Dunn Index graph
plt.plot(numOfClusters, dunnIndices)
plt.title("Dunns Index for time_in_hospital vs num_medications")
plt.xlabel("Clusters")
plt.ylabel("Dunns Index")
plt.savefig("Dunns Index Graph")
plt.show()